#include <iostream>
#include <vector>
#include"Function.h"
#include"exercise8.h"
#include<time.h>
//#include<random>
#include<cstdlib>

using namespace std;


void exercise_8() {
	vector<vector<double>> A = { {1.0000000000,4.9176000000,1.0000000000,3.4720000000,0.9980000000,1.0000000000,7.0000000000,4.0000000000,42.0000000000,3.0000000000,1.0000000000,0.0000000000},{1.0000000000,5.0208000000,1.0000000000,3.5310000000,1.5000000000,2.0000000000,7.0000000000,4.0000000000,62.0000000000,1.0000000000,1.0000000000,0.0000000000},{1.0000000000,4.5429000000,1.0000000000,2.2750000000,1.1750000000,1.0000000000,6.0000000000,3.0000000000,40.0000000000,2.0000000000,1.0000000000,0.0000000000},{1.0000000000,4.5573000000,1.0000000000,4.0500000000,1.2320000000,1.0000000000,6.0000000000,3.0000000000,54.0000000000,4.0000000000,1.0000000000,0.0000000000},{1.0000000000,5.0597000000,1.0000000000,4.4550000000,1.1210000000,1.0000000000,6.0000000000,3.0000000000,42.0000000000,3.0000000000,1.0000000000,0.0000000000},{1.0000000000,3.8910000000,1.0000000000,4.4550000000,0.9880000000,1.0000000000,6.0000000000,3.0000000000,56.0000000000,2.0000000000,1.0000000000,0.0000000000},{1.0000000000,5.8980000000,1.0000000000,5.8500000000,1.2400000000,1.0000000000,7.0000000000,3.0000000000,51.0000000000,2.0000000000,1.0000000000,1.0000000000},{1.0000000000,5.6039000000,1.0000000000,9.5200000000,1.5010000000,0.0000000000,6.0000000000,3.0000000000,32.0000000000,1.0000000000,1.0000000000,0.0000000000},{1.0000000000,15.4202000000,2.5000000000,9.8000000000,3.4200000000,2.0000000000,10.0000000000,5.0000000000,42.0000000000,2.0000000000,1.0000000000,1.0000000000},{1.0000000000,14.4598000000,2.5000000000,12.8000000000,3.0000000000,2.0000000000,9.0000000000,5.0000000000,14.0000000000,4.0000000000,1.0000000000,1.0000000000},{1.0000000000,5.8282000000,1.0000000000,6.4350000000,1.2250000000,2.0000000000,6.0000000000,3.0000000000,32.0000000000,1.0000000000,1.0000000000,0.0000000000},{1.0000000000,5.3003000000,1.0000000000,4.9883000000,1.5520000000,1.0000000000,6.0000000000,3.0000000000,30.0000000000,1.0000000000,2.0000000000,0.0000000000},{1.0000000000,6.2712000000,1.0000000000,5.5200000000,0.9750000000,1.0000000000,5.0000000000,2.0000000000,30.0000000000,1.0000000000,2.0000000000,0.0000000000},{1.0000000000,5.9592000000,1.0000000000,6.6660000000,1.1210000000,2.0000000000,6.0000000000,3.0000000000,32.0000000000,2.0000000000,1.0000000000,0.0000000000},{1.0000000000,5.0500000000,1.0000000000,5.0000000000,1.0200000000,0.0000000000,5.0000000000,2.0000000000,46.0000000000,4.0000000000,1.0000000000,1.0000000000},{1.0000000000,5.6039000000,1.0000000000,9.5200000000,1.5010000000,0.0000000000,6.0000000000,3.0000000000,32.0000000000,1.0000000000,1.0000000000,0.0000000000},{1.0000000000,8.2464000000,1.5000000000,5.1500000000,1.6640000000,2.0000000000,8.0000000000,4.0000000000,50.0000000000,4.0000000000,1.0000000000,0.0000000000},{1.0000000000,6.6969000000,1.5000000000,6.0920000000,1.4880000000,1.5000000000,7.0000000000,3.0000000000,22.0000000000,1.0000000000,1.0000000000,1.0000000000},{1.0000000000,7.7841000000,1.5000000000,7.1020000000,1.3760000000,1.0000000000,6.0000000000,3.0000000000,17.0000000000,2.0000000000,1.0000000000,0.0000000000},{1.0000000000,9.0384000000,1.0000000000,7.8000000000,1.5000000000,1.5000000000,7.0000000000,3.0000000000,23.0000000000,3.0000000000,3.0000000000,0.0000000000},{1.0000000000,5.9894000000,1.0000000000,5.5200000000,1.2560000000,2.0000000000,6.0000000000,3.0000000000,40.0000000000,4.0000000000,1.0000000000,1.0000000000},{1.0000000000,7.5422000000,1.5000000000,4.0000000000,1.6900000000,1.0000000000,6.0000000000,3.0000000000,22.0000000000,1.0000000000,1.0000000000,0.0000000000},{1.0000000000,8.7951000000,1.5000000000,9.8900000000,1.8200000000,2.0000000000,8.0000000000,4.0000000000,50.0000000000,1.0000000000,1.0000000000,1.0000000000},{1.0000000000,6.0931000000,1.5000000000,6.7265000000,1.6520000000,1.0000000000,6.0000000000,3.0000000000,44.0000000000,4.0000000000,1.0000000000,0.0000000000},{1.0000000000,8.3607000000,1.5000000000,9.1500000000,1.7770000000,2.0000000000,8.0000000000,4.0000000000,48.0000000000,1.0000000000,1.0000000000,1.0000000000},{1.0000000000,8.1400000000,1.0000000000,8.0000000000,1.5040000000,2.0000000000,7.0000000000,3.0000000000,3.0000000000,1.0000000000,3.0000000000,0.0000000000},{1.0000000000,9.1416000000,1.5000000000,7.3262000000,1.8310000000,1.5000000000,8.0000000000,4.0000000000,31.0000000000,4.0000000000,1.0000000000,0.0000000000},{1.0000000000,12.0000000000,1.5000000000,5.0000000000,1.2000000000,2.0000000000,6.0000000000,3.0000000000,30.0000000000,3.0000000000,1.0000000000,1.0000000000} };
	int m = A.size(), n = A[0].size(), p, q, s, r, k = 0;
	double cos, sin,a,b,c,d;
	vector<vector<double>> U, V, B, T, B22, IU, IV,I={{-1}},A0;
	V = I_matrix(n);
	U = I_matrix(m);
	B = I_matrix(n);
	T = make_zero_matrix(m, n);
	B = two_diagonal(A, U, V);
	A0 = make_zero_matrix(m, n);
	for (int i = 0; i < n - 1; i++) if (fabs(B[i][i + 1]) <= (fabs(B[i][i]) + fabs(B[i + 1][i + 1])) * pow(10, -10))B[i][i + 1] = 0;
	for (int i = 0; i < n; i++) if (fabs(B[i][i]) < Matrix_norm(B, -1) * pow(10, -10))B[i][i] = 0;
	p_q(B, p, q);
	while (q < n) {
		s = 0;
		r = n - p - q;//B22的大小
		B22 = I_matrix(r);
		B22 = Matrix_block(B, p, p, r, r);
		for (int i = 0; i < r - 1; i++) {
			if (B22[i][i] == 0) {
				s++;
				for (int j = i + 1; j < r - 1; j++) {
					cos = sin = 0;
					givens(cos, sin, B22[j][j], B22[i][j]);
					a = B[i][j];
					c = B[j][j];
					d = B[j][j + 1];
					B[i][j] = -sin * a + cos * c;
					B[i][j + 1] = cos * d;
					B[j][j] = cos * a + sin * c;
					B[j][j + 1] = sin * d;//更新B
					vector<vector<double>> W;
					W = make_zero_matrix(m, m);
					W = U;
					for (int f = 0; f < m; f++) {
						W[p+i][f] = -sin * U[p+i][f] + cos * U[p+j][f];
						W[p+j][f] = cos * U[p+i][f] + sin * U[p+j][f];
					}
					U = W;
					//将givens变换累积到U上
				}
				cos = sin = 0;
				int j = r - 1;
				givens(cos, sin, B22[j][j], B22[i][j]);
				a = B22[i][j];
				b = B22[j][j];
				B22[j][j] = cos * a + sin * b;
				B22[i][j] = -sin * a + cos * b;
				//U = givens_mul(U, c, s, p + i, p + j, -1);;
				vector<vector<double>> W;
				W = make_zero_matrix(m, m);
				W = U;
				for (int f = 0; f < m; f++) {
					W[p + i][f] = -sin * U[p + i][f] + cos * U[p + j][f];
					W[p + j][f] = cos * U[p + i][f] + sin * U[p + j][f];
				}
				U = W;
				cos = sin = 0;
				//最后一列的操作
			}
		}//若B22对角元有0,用givens变换把这一行全变为0   
		if (s == 0) {
			k++;
			if (r == 2) {
				a = B22[0][0];
				b = B22[0][1];
				d = B22[1][1];
				cos = (a + d) / sqrt(pow(a + d, 2) + pow(b, 2));
				sin = -b / sqrt(pow(a + d, 2) + pow(b, 2));
				B22 = givens_mul(B22, cos, sin, 0, 1, 1);
				U = givens_mul(U, cos, sin, p, p + 1, 1);
				vector<vector<double>> J;
				J = I_matrix(2);
				int time = 0;
				B22 = Pass_Jacobi(B22, J, time);
				B = Matrix_block_replace(B, p, p, r, r, B22, 1);
				a = J[0][0]; b = J[0][1]; c = J[1][0]; d = J[1][1];
				U = Matrix_block_mul(U, p, 0, 2, m, Matrix_T(J), -1);
				V = Matrix_block_mul(V, 0, p, n, 2, J, 1);
				a = sign(B22[0][0]); b = sign(B22[1][1]);
				J = { {a,0},{0,b} };
				U = Matrix_block_mul(U, p, 0, 2, m, J, -1);
			}//7.6.2要求n>=3,这里是n=2的情形
			else {
				k++;
				IU = I_matrix(r);
				IV = I_matrix(r);
				B22 = Wilkinson_SVD(B22, IU, IV);
				U = Matrix_block_mul(U, p, 0, r, m, IU, -1);
				V = Matrix_block_mul(V, 0, p, n, r, IV, 1);
				B = Matrix_block_replace(B, p, p, r, r, B22, 1);

			}//算法7.6.2带Wilkinson位移的SVD迭代
		}
		//SVD迭代
		for (int i = 0; i < n - 1; i++) if (fabs(B[i][i + 1]) <= (fabs(B[i][i]) + fabs(B[i + 1][i + 1])) * pow(10, -10))B[i][i + 1] = 0;
		for (int i = 0; i < n; i++) if (fabs(B[i][i]) < Matrix_norm(B, -1) * pow(10, -10))B[i][i] = 0;
		p_q(B, p, q);
	}
	for (int i = 0; i < n; i++) {
		if (B[i][i] < 0) {
			B[i][i] = -B[i][i];
			V = Matrix_block_mul(V, 0, i, n, 1, I, 1);
		}
	}
	T = Matrix_block_add(T, 0, 0, n, n, B, 1);
	A0 = Matrix_Mul(Matrix_Mul(Matrix_T(U), T), Matrix_T(V));
	double ep, eq, et;
	IU = I_matrix(m);
	IV = I_matrix(n);
	ep = Matrix_absmax(Matrix_Subtracition(Matrix_Mul(U, Matrix_T(U)), IU));
	eq = Matrix_absmax(Matrix_Subtracition(Matrix_Mul(V, Matrix_T(V)), IV));
	et= Matrix_absmax(Matrix_Subtracition(A0, A));
	cout << "A = UT T VT:" << endl;
	cout << "迭代次数:" << k << endl;
	cout << "奇异值从小到大:" << endl;
	cout_Singular_values(B, 1);
	cout << endl;
	cout << "ep = " << ep << endl;
	cout << "eq = " << eq << endl;
	cout << "et = " << et << endl;
	cout << "A=UT*T*VT" << endl;
	cout << "T=" << endl;
	cout_Matrix(T);
	cout << "U=" << endl;
	cout_Matrix(U);
	cout << "V=" << endl;
	cout_Matrix(V);                                                                //输出
}





















